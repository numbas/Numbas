Numbas.queueScript('diagnostic_scripts',[],function() {
    Numbas.raw_diagnostic_scripts = {
        "diagnosys": 
"state (Produces the initial value of the state object): // should be renamed \"initial_state\"\n    [\n        \"topics\": map(\n            [\n                \"topic\": topic,\n                \"status\": \"unknown\" // \"unknown\", \"passed\", or \"failed\"\n            ],\n            topic,\n            values(topics)\n        ),\n        \"retries\": 3,\n        \"finished\": false,\n    ]\n\ntopics_by_objective (A dictionary mapping a learning objective name to a list of indices of topics):\n    dict(map(\n        let(\n            ltopics, values(topics),\n            indices, filter(lo[\"name\"] in ltopics[j][\"learning_objectives\"], j, 0..len(ltopics)-1),\n            [lo[\"name\"],indices]\n        ),\n        lo,\n        learning_objectives\n    ))\n\nunknown_topics (Which topics are still unknown?): \n    map(x[\"topic\"],x,filter(x[\"status\"]=\"unknown\",x,state[\"topics\"]))\n\nfirst_topic (The first topic to pick a question on):\n    unknown_topics[floor(len(unknown_topics)/2)][\"name\"]\n\nfirst_question (The first question to show the student):\n    random(topics[first_topic][\"questions\"])\n\nget_dependents (An expression which gets the topics to update after answering a question):\n    expression(\"\"\"\n        [target] + flatten(map(eval(get_dependents,[\"target\":t,\"correct\":correct]),t,topics[target][if(correct,\"depends_on\",\"leads_to\")]))\n    \"\"\")\n\ncorrect (Did the student get the current question right?):\n    current_question[\"credit\"]=1\n\nafter_answering (Update the state after the student answers a question):\n    let(\n        ntopics, eval(get_dependents,[\"target\":current_topic,\"correct\":correct])\n    ,   nstate, state + ['topics': map(\n                    if(tstate[\"topic\"][\"name\"] in ntopics, tstate + [\"status\":if(correct,\"passed\",\"failed\")], tstate),\n                    tstate,\n                    state[\"topics\"]\n                )]\n    , nstate\n    )\n\naction_retry (Use up one retry and visit the same topic again):\n    [\n        \"label\": translate(\"diagnostic.use retry\"),\n        \"state\": state + [\"retries\": state[\"retries\"]-1],\n        \"next_question\": random(topics[current_topic][\"questions\"])\n    ]\n\naction_stop (Stop the exam):\n    [\n        \"label\": translate(\"diagnostic.end test\"),\n        \"state\": state,\n        \"next_question\": nothing\n    ]\n\naction_move_on (Move to the next topic, or end the exam if there are no more):\n    let(\n        state, after_answering,\n        immediate_next_topics, topics[current_topic][if(correct, \"leads_to\", \"depends_on\")],\n        unknown_topics, map(x[\"topic\"],x,filter(x[\"status\"]=\"unknown\",x,state[\"topics\"])),\n        unknown_immediate_topics, filter(x[\"name\"] in immediate_next_topics,x,unknown_topics),\n        next_topics, if(len(unknown_immediate_topics), unknown_immediate_topics, unknown_topics),\n        finished, len(next_topics)=0 or state[\"finished\"],\n        topic,\n            if(not finished,\n                next_topics[floor(len(next_topics)/2)][\"name\"]\n            ,\n                nothing\n            ),\n        [\n            \"label\": translate(\"diagnostic.move to next topic\"),\n            \"state\": after_answering,\n            \"next_question\": if(not finished, random(topics[topic][\"questions\"]), nothing)\n        ]\n    )\n\ncan_move_on:\n    action_move_on[\"next_question\"]<>nothing\n\nnext_actions (Actions to offer to the student when they ask to move on):\n    let(\n        feedback, retries_feedback+\"\\n\\n\"+translate(\"diagnostic.next step question\")\n    ,   [\n            \"feedback\": feedback,\n            \"actions\": if(not correct and state[\"retries\"]>0, [action_retry], []) + if(can_move_on,[action_move_on],[action_stop])\n        ]\n    )\n\nafter_exam_ended (Update the state after the exam ends):\n    let(\n        state, after_answering,\n        ntopics, map(t+[\"status\": if(t[\"status\"]=\"unknown\",\"failed\",t[\"status\"])],t,state[\"topics\"]),\n        state+[\"finished\": true]\n    )\n\nfinished (Is the test finished? True if there are no unknown topics):\n    len(unknown_topics)=0 or state[\"finished\"]\n\ntotal_progress:\n    let(\n        num_topics, len(state[\"topics\"]),\n        known, filter(tstate[\"status\"]<>\"unknown\",tstate,state[\"topics\"]),\n        passed, filter(tstate[\"status\"]=\"passed\",tstate,known),\n        num_known, len(known),\n        num_passed, len(passed),\n        [\n            \"name\": translate(\"control.total\"),\n            \"progress\": if(num_topics>0,num_known/num_topics,0), \n            \"credit\": if(num_known>0,num_passed/num_topics,0)\n        ]\n    )\n\nlearning_objective_progress:\n    map(\n        let(\n            tstates, map(state[\"topics\"][j],j,topics_by_objective[lo[\"name\"]]),\n            known, filter(tstate[\"status\"]<>\"unknown\",tstate,tstates),\n            passed, filter(tstate[\"status\"]=\"passed\",tstate,known),\n            num_topics, len(tstates),\n            num_known, len(known),\n            num_passed, len(passed),\n            [\"name\": lo[\"name\"], \"progress\": if(num_topics>0,num_known/num_topics,0), \"credit\": if(finished,num_passed/num_topics,if(num_known>0,num_passed/num_known,0))]\n        ),\n        lo,\n        learning_objectives\n    )\n\nprogress (Progress on each of the learning objectives, plus total progress):\n    learning_objective_progress+\n    total_progress\n\nretries_feedback:\n    translate(\"diagnostic.now assessing topic\", [\"current_topic\": current_topic]) + \" \" +\n    let(\n        retries, state[\"retries\"], \n        pluralise(retries, translate(\"diagnostic.one retry left\"), translate(\"diagnostic.retries left\", [\"retries\": retries ]))\n    )\n    + \" \" +\n    let(\n        p,total_progress[\"progress\"],\n        percentage, dpformat(100p, 0),\n        translate(\"diagnostic.percentage completed\", [\"percentage\": percentage])\n    )\n\nweak_objective_threshold (The amount of credit below which a learning objective is considered weak):\n    0.6\n\nfinished_feedback:\n    let(\n        weak_objectives, filter(p[\"credit\"]<weak_objective_threshold, p, learning_objective_progress),\n    //\n        translate(\"diagnostic.test is over\") + \" \"\n        +\n        if(len(weak_objectives)=0,\n            translate(\"diagnostic.passed all lo\")\n        ,\n            translate(\"diagnostic.more work on lo\", [\"los\": \n                join(map(lo[\"name\"], lo, weak_objectives),\", \")])\n        )\n    )\n\nfeedback:\n    if(finished,\n        finished_feedback,\n        retries_feedback\n    )\n\n",
        "mastery": 
"pre_state:\n    [\n        \"topics\": map(\n            [\n                \"topic\": topic,\n                \"status\": if(len(topic[\"questions\"])=0,\"passed\",\"unknown\")\n            ],\n            topic,\n            values(topics)\n        ),\n        \"finished\": false\n    ]\n\nfirst_topic (The first topic to assess):\n    let(\n        topics, pre_state[\"topics\"],\n    //\n        filter(len(t[\"topic\"][\"depends_on\"])=0,t,topics)[0]\n    )\n\nstate:\n    eval(start_topic,[\"state\": pre_state, \"topic\": first_topic])\n\nstart_topic (An expression to make a question queue for the given topic):\n    expression(\"\"\"\n        state + [\n            \"current_topic\": topic,\n            \"question_queue\": map(\n                [\"question\": q, \"status\": \"unknown\"],\n                q,\n                topic[\"topic\"][\"questions\"]\n            )\n        ]\n    \"\"\")\n\n\n\nfirst_question:\n    eval(get_next_question)\n\ncorrect (Did the student get the current question right?):\n    current_question[\"credit\"]=1\n\nafter_answering (Update the state after the student answers a question):\n    let(\n        queue, state[\"question_queue\"],\n        nq, state[\"question_queue\"][0] + [\"status\": if(correct,\"passed\",\"failed\")],\n        nqueue, queue[1..len(queue)] + if(correct,[],[nq]),\n        ntopics,\n            if(len(nqueue)=0,\n                map(if(t=state[\"current_topic\"], t+[\"status\":\"passed\"], t), t, state[\"topics\"]),\n                state[\"topics\"]\n            ),\n        nstate, state + [\"topics\": ntopics, \"question_queue\": nqueue],\n    //\n        nstate\n    )\n\nnext_topic (The next topic to assess):\n    expression(\"\"\"\n        let(\n            topics, state[\"topics\"],\n            topicdict, dict(map([t[\"topic\"][\"name\"],t], t, topics)),\n            available_topics,\n                filter(let(\n                    all_deps_passed, all(map(topicdict[tn][\"status\"]=\"passed\",tn,t[\"topic\"][\"depends_on\"])),\n                    all_deps_passed and t[\"status\"]<>\"passed\"\n                ),t,topics),\n        //\n           if(len(available_topics)>0,available_topics[0],nothing)\n        )\n    \"\"\")\n\nget_next_question (An expression to get the next question from the queue):\n    expression(\"\"\"\n        let(\n            queue, state[\"question_queue\"],\n        //\n            if(len(queue)>0,queue[0][\"question\"], nothing)\n        )\n    \"\"\")\n\naction_next_question_same_topic (Move to the next question in the queue):\n    [\n        \"label\": translate(\"diagnostic.move to next question in topic\"),\n        \"state\": after_answering,\n        \"next_question\": eval(get_next_question,[\"state\": after_answering])\n    ]\n\naction_next_topic (Move to the next topic):\n    let(\n        state, after_answering,\n        topic, eval(next_topic),\n        nstate, if(topic<>nothing,eval(start_topic),state),\n    //\n        [\n            \"label\": translate(\"diagnostic.move to next topic\"),\n            \"state\": nstate,\n            \"next_question\": eval(get_next_question,[\"state\":nstate])\n        ]\n    )\n\nnext_actions:\n    let(\n        state, after_answering,\n        queue_empty, len(state[\"question_queue\"])=0,\n        actions, \n            switch(\n                not queue_empty,\n                    [action_next_question_same_topic]\n            ,   eval(next_topic)<>nothing,\n                    [action_next_topic]\n            ,\n                []\n            ),\n    //\n        [\n            \"feedback\": \"\",\n            \"actions\": actions\n        ]\n    )\n\nprogress:\n    let(\n        passed_topics, filter(t[\"status\"]=\"passed\",t,state[\"topics\"]),\n        num_passed_topics, len(passed_topics),\n        num_topics, len(state[\"topics\"]),\n        exam_progress, num_passed_topics/num_topics,\n        topic_credit, 1-len(state[\"question_queue\"])/len(state[\"current_topic\"][\"topic\"][\"questions\"]),\n        current_topic, state[\"current_topic\"][\"topic\"][\"name\"],\n        lo_progress, map(\n            let(\n                ltopics, filter(lo[\"name\"] in t[\"topic\"][\"learning_objectives\"], t, state[\"topics\"]),\n                passed, filter(t[\"status\"]=\"passed\",t,ltopics),\n                p, len(passed)/len(topics),\n                [\"name\": lo[\"name\"], \"progress\": p, \"credit\": p]\n            ),\n            lo,\n            learning_objectives\n        ),\n        topic_progress, [[\"name\": \"Current topic: {current_topic}\", \"progress\": topic_credit, \"credit\": topic_credit]],\n    //\n        topic_progress + lo_progress +\n        [\n            [\"name\": translate(\"control.total\"), \"progress\": exam_progress, \"credit\": exam_progress]\n        ]\n    )\n\nfeedback: \n    if(state[\"finished\"],\n        translate(\"diagnostic.complete\")\n    ,\n        translate(\"diagnostic.studying topic\", [\"topic\": state[\"current_topic\"][\"topic\"][\"name\"]])\n    )\n\nafter_exam_ended:\n    after_answering + [\"finished\": true]\n"
	};
});
